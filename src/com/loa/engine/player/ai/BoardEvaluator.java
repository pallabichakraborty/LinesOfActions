package com.loa.engine.player.ai;
/*****************************************************************************************
 * Class Name: BoardEvaluator
 * Description: Class used to evaluate a transition board
 * 
 * Reference
 * -----------
 * 1) https://www.youtube.com/watch?v=Cm70y54cDIo
 * 2) Java Chess Programming https://www.youtube.com/watch?v=5SKOOG3TwVU
 * 
 * Changes Done
 * --------------
 * Description of Changes		           Date of Modification         Modification Done By
 * Initial Draft							23-Mar-2016					Pallabi
 * Change the eval condition to distance	27-Apr-2016					Pallabi
 * between the pieces
 *******************************************************************************************/

import java.util.Collection;

import com.loa.engine.Alliance;
import com.loa.engine.board.Board;
import com.loa.engine.piece.Piece;
import com.loa.engine.player.Player;

public class BoardEvaluator {

	//Returns the score for the  board for a particular depth
	public int evaluate(final Board board,final int depth,Alliance maxPlayer) 
	{
		//If the current player is the maxPlayer then return the score for the max player else return the score of the opponent
		if(board.currentPlayer().getAlliance()!=maxPlayer)
		{
			return scorePlayer(board, board.currentPlayer().getOpponent(), depth);
		}
		return scorePlayer(board, board.currentPlayer(), depth);
	}

	//Score generated by adding mobility,win,number of pieces of opponent and minimum unconnected connect
	private int scorePlayer(Board board, Player player, int depth) 
	{
		return (int) (win(player,board)+
				checkForDistanceBetweenPieces(player,board)+
				mobility(player,board)+
				connectedPercentage(player,board));
	}


	// Checks for the win of the player
	private int win(Player player,Board board) {
		if(player.getAlliance()==Alliance.BLACK && Board.isBlackWinner(board))
		{
			return 100;
		}
		else if((player.getAlliance()==Alliance.WHITE && Board.isWhiteWinner(board)))
		{
			return 100;
		}
		return 0;

	}

	//Gives weightage to least number of unconnected pieces
	// Finds the difference between the number of pieces and the maximum connected count and the lower value gets preference
	private float connectedPercentage(Player player,Board board)
	{
		if(player.getAlliance()==Alliance.WHITE)
		{
			return (float)(-1*((board.getWhitePieces().size()-board.getWhiteMaxConnectedCount())/(float)board.getWhitePieces().size()*15.0));
		}
		else if(player.getAlliance()==Alliance.BLACK)
		{
			return (float)(-1*((board.getBlackPieces().size()-board.getBlackMaxConnectedCount())/(float)board.getBlackPieces().size()*15.0));
		}
		return 0;
	}

	//Checks for the legal moves of the player
	private int mobility(Player player,Board board) 
	{
		return player.getLegalMoves().size();
	}
	//Find center of mass of pieces and then check for clustering using lesser distance from center of mass
	private float checkForDistanceBetweenPieces(Player player,Board board)
	{
		int playerDist = getDistanceBetweenPieces(player.getActivePieces());
		//Higher the distance penalize the player
		int result = -1*playerDist;

		return result;

	}

	//Calculate the distance of the pieces on the board
	private int getDistanceBetweenPieces(Collection<Piece> pieces){
		int sum = 0;
		for(Piece piece:pieces){
			for(Piece refpiece:pieces){
				sum += calcDistanceBetweenPieces(piece, refpiece);
			}
		}
		return sum;
	}

	//Calculate Euclidean Distance between 2 positions
	private double calcDistanceBetweenPieces(Piece move1, Piece move2){
		int x = (int) Math.pow(move1.getPiecePosition()/10-move2.getPiecePosition()/10,2);
		int y = (int) Math.pow(move1.getPiecePosition()%10-move2.getPiecePosition()%10,2);
		return Math.sqrt(x+y);
	}


}
